# armvm

**armvm** is an ARMv7 assembler and virtual machine that allows you to run 32-bit ARM assembly code on any host architecture. The project consists of two main components:

1. **ARM Assembler**: Compiles ARM assembly source code into bytecode
2. **ARM VM**: Executes ARM32 bytecode in a virtual environment with syscall support

## Features

- **ARMv7 32-bit ARM Support**: Full implementation of ARMv7 instruction set
- **Cross-Architecture**: Run ARM32 code on x86, x86_64, ARM64, or any other architecture
- **Assembly-to-Bytecode Compiler**: Converts ARM assembly directly to executable bytecode
- **Syscall Interface**: Extensible system call mechanism for host function integration
- **Memory Management**: Built-in stack and heap with configurable sizes
- **Zero Dependencies**: Self-contained implementation in C

## Assembly Syntax

The assembler supports **ARM UAL (Unified Assembly Language)** syntax with Apple/Xcode conventions, specifically targeting **ARMv7 32-bit ARM** architecture.

### Supported Assembly Syntax

This assembler was designed to parse assembly code generated by **Xcode's ARM32 compiler** (using the `-arch armv7` flag). The syntax follows ARM UAL with Apple Mach-O object file conventions.

**Key Characteristics:**
- **Architecture**: ARMv7 (32-bit ARM)
- **Syntax Style**: ARM UAL (Unified Assembly Language)
- **Object Format**: Apple Mach-O conventions
- **Registers**: r0-r15 (with sp=r13, lr=r14, pc=r15)
- **Instruction Width**: 32-bit instructions
- **Endianness**: Little-endian

### Instruction Examples

```arm
@ Data processing
mov r0, #10              @ Move immediate
add r0, r0, r1           @ Add registers
sub r2, r0, r1           @ Subtract

@ Conditional execution
cmp r0, #9               @ Compare
addgt r0, #10            @ Add if greater than
movls r0, #10            @ Move if lower or same

@ Memory operations
ldr r0, [sp, #4]         @ Load from stack
str r1, [r0, #8]         @ Store to memory
push {r0-r3, lr}         @ Push multiple registers
pop {r0-r3, pc}          @ Pop and return

@ Shifts and rotates
mov r1, r1, lsl #2       @ Logical shift left
add r0, r0, r1, lsr #1   @ Add with shifted operand

@ Branches
b label                  @ Unconditional branch
bl function              @ Branch with link (call)
bx lr                    @ Branch and exchange (return)

@ PC-relative addressing
ldr r0, =constant        @ Load constant (pseudo-instruction)
adr r0, label            @ Load address of label
```

### Supported Directives

```arm
.ascii "text"            @ String data (no null terminator)
.asciz "text"            @ Null-terminated string
.byte 0x42               @ 8-bit data
.short 0x1234            @ 16-bit data
.long 0x12345678         @ 32-bit data
.space 100               @ Reserve bytes

.globl symbol            @ Global symbol export
.set name, value         @ Define constant
.p2align 2               @ Align to power of 2
.section __TEXT,__text   @ Section directive

@ Apple/Mach-O specific
.subsections_via_symbols
.build_version
.indirect_symbol
```

### Supported Instructions

**Data Processing:**
`and`, `eor`, `sub`, `rsb`, `add`, `adc`, `sbc`, `rsc`, `tst`, `teq`, `cmp`, `cmn`, `orr`, `mov`, `bic`, `mvn`

**Multiply:**
`mul`, `mla`, `umull`, `umlal`, `smull`, `smlal`

**Memory Access:**
`ldr`, `ldrb`, `ldrh`, `ldrsb`, `ldrsh`, `str`, `strb`, `strh`, `ldm`, `stm`
(Note: Byte/halfword/signed variants are parsed as suffixes to LDR/STR base instructions)

**Branch:**
`b`, `bl`, `bx`

**Shift Instructions:**
`lsl`, `lsr`, `asr`, `ror` (converted internally to MOV with shift operands)

**Condition Codes:**
`eq`, `ne`, `cs/hs`, `cc/lo`, `mi`, `pl`, `vs`, `vc`, `hi`, `ls`, `ge`, `lt`, `gt`, `le`, `al`

## Generating Compatible Assembly

### Using Clang/LLVM

To generate ARMv7 assembly compatible with this assembler using Clang:

```bash
# Compile C to ARMv7 assembly
clang -S -arch armv7 -target armv7-apple-darwin -O2 input.c -o output.s

# For iOS devices (32-bit)
clang -S -arch armv7 -isysroot $(xcrun --sdk iphoneos --show-sdk-path) \
      -miphoneos-version-min=10.0 -O2 input.c -o output.s
```

### Using GCC ARM Cross-Compiler

```bash
# Using arm-none-eabi-gcc
arm-none-eabi-gcc -S -march=armv7-a -marm -O2 input.c -o output.s

# Using arm-linux-gnueabi-gcc
arm-linux-gnueabi-gcc -S -march=armv7-a -marm -O2 input.c -o output.s
```

**Note**: Assembly generated by GCC may need minor syntax adjustments:
- GCC uses `@` for comments; this assembler supports both `@` and `;`
- Some GCC-specific directives may need to be removed or adapted
- Apple/Mach-O specific directives (like `.subsections_via_symbols`) are optional

### Using Xcode (Original Target)

In Xcode, configure your target with:
```
Build Settings:
- Architecture: armv7
- Valid Architectures: armv7
- Deployment Target: iOS 10.0 or earlier (32-bit support)

To generate assembly:
1. Select Product > Perform Action > Assemble [filename].c
2. Or use: clang -S -arch armv7 [source.c] -o [output.s]
```

## Building

The project uses Xcode for development but can be built with standard C compilers:

```bash
# Using Xcode
xcodebuild -project armvm.xcodeproj -scheme armvm

# Using GCC/Clang directly
cd armvm
gcc -o armvm armvm.c compiler.c armcomp.c expr.c memory.c libpvm.c -lm

# Or with Clang
clang -o armvm armvm.c compiler.c armcomp.c expr.c memory.c libpvm.c -lm
```

## Command-Line Usage

The `armvm` executable is an assembler that compiles ARM assembly files to bytecode:

```bash
# Compile assembly to bytecode
./armvm -o output.bin input.s

# Compile multiple files
./armvm -o program.bin file1.s file2.s file3.s
```

**Output Format:**
- `.bin` file: Contains compiled bytecode with header
- `_d` file: Debug symbols (e.g., `output.bin_d`)

The compiled bytecode includes:
- Program header with magic number (0x4143524F / "ORCA" in little-endian)
- Executable ARM32 instructions
- Symbol table with global labels and their positions

## Programmatic Usage

### Using the VM in Your Application

```c
#include "vm.h"

// Helper macro to convert register value to memory address
#define VMA(A) ((void *)(vm->memory + vm->r[A]))

// Implement syscall handler
DWORD my_syscall(LPVM vm, DWORD call_id) {
    switch (call_id) {
        case 1: // strlen
            return strlen((char*)VMA(0));
        case 2: // puts  
            return puts((char*)VMA(0));
        // Add more syscalls as needed
        default: return 0;
    }
}

int main() {
    // Load compiled assembly bytecode
    FILE *fp = fopen("program.bin", "rb");
    fseek(fp, 0, SEEK_END);
    DWORD size = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    BYTE *program = malloc(size);
    fread(program, size, 1, fp);
    fclose(fp);
    
    // Create VM with 64KB stack and heap
    LPVM vm = vm_create(my_syscall, 64*1024, 64*1024, program, size);
    
    // Execute from entry point (usually offset 0)
    execute(vm, 0);
    
    // Get return value from r0
    DWORD result = vm->r[0];
    
    // Cleanup
    vm_shutdown(vm);
    free(program);
    
    return result;
}
```

### Complete Example: Compile and Run

```bash
# 1. Write ARM assembly
cat > hello.s << 'EOF'
.globl _main
_main:
    mov r0, #42
    bx lr
EOF

# 2. Compile to bytecode
./armvm -o hello.bin hello.s

# 3. Run with your VM wrapper (you need to implement this)
./your_vm_runner hello.bin
```

## Architecture Details

- **Registers**: 16 general-purpose registers (r0-r15)
  - r13: Stack Pointer (SP)
  - r14: Link Register (LR)
  - r15: Program Counter (PC)
- **CPSR Flags**: N (Negative), Z (Zero), C (Carry), V (Overflow)
- **Memory Model**: Separate stack and heap with configurable sizes
- **Instruction Format**: 32-bit ARM instructions (not Thumb)
- **Default Sizes**: 64KB stack, 64KB heap

## Running Tests

The project includes XCTest-based unit tests in the `armtest` directory:

```bash
# Run tests with Xcode
xcodebuild test -project armvm.xcodeproj -scheme armtest

# Tests include:
# - Basic instructions (MOV, ADD, SUB, etc.)
# - Memory operations (LDR, STR, PUSH, POP)
# - Conditional execution
# - Shifts and rotates
# - Branch instructions
# - Complex programs (linked lists, string operations, etc.)
```

## License

This project is licensed under the **GNU General Public License v3.0**. See the LICENSE file for complete details.
